---
sidebar: sidebar 
permalink: concept_device_resolution_regex_examples.html 
keywords: Automatic, AR, AHR, Host, automatic device resolution, FC, Identify, regex, expressions 
summary:  
---
= 정규 표현식 예제
:hardbreaks:
:allow-uri-read: 


[role="lead"]
소스 명명 전략으로 정규 표현식 방식을 선택한 경우, 정규 표현식 예시를 Data Infrastructure Insights 자동 해결 방법에서 사용하는 고유한 표현식에 대한 가이드로 사용할 수 있습니다.



== 정규 표현식 서식 지정

Data Infrastructure Insights 자동 확인을 위한 정규 표현식을 만들 때 _FORMAT_이라는 필드에 값을 입력하여 출력 형식을 구성할 수 있습니다.

기본 설정은 \1입니다. 즉, 정규 표현식과 일치하는 영역 이름은 정규 표현식에 의해 생성된 첫 번째 변수의 내용으로 대체됩니다.  정규 표현식에서는 변수 값이 괄호로 묶인 문장을 통해 생성됩니다.  괄호 안의 문장이 여러 개 나타나는 경우, 변수는 왼쪽에서 오른쪽으로 숫자로 참조됩니다.  변수는 어떤 순서로든 출력 형식에서 사용될 수 있습니다.  FORMAT 필드에 상수 텍스트를 추가하여 출력에 상수 텍스트를 삽입할 수도 있습니다.

예를 들어, 이 영역 명명 규칙에 대해 다음과 같은 영역 이름이 있을 수 있습니다.

 [Zone number]_[data center]_[hostname]_[device type]_[interface number]
* S123_Miami_hostname1_filer_FC1
* S14_Tampa_hostname2_switch_FC4
* S3991_Boston_hostname3_windows2K_FC0
* S44_Raleigh_hostname4_solaris_FC1


출력 형식은 다음과 같을 수 있습니다.

 [hostname]-[data center]-[device type]
이렇게 하려면 호스트 이름, 데이터 센터, 장치 유형 필드를 변수에 캡처하여 출력에 사용해야 합니다.  다음 정규 표현식은 이를 수행합니다.

 .*?_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_([a-zA-Z0-9]+)_.*
괄호 세트가 세 개이므로 변수 \1, \2, \3이 채워집니다.

그런 다음 다음 형식을 사용하여 원하는 형식으로 출력을 받을 수 있습니다.

 \2-\1-\3
출력 결과는 다음과 같습니다.

....
hostname1-Miami-filer
hostname2-Tampa-switch
hostname3-Boston-windows2K
hostname4-Raleigh-solaris
....
변수 사이의 하이픈은 서식이 지정된 출력에 삽입되는 상수 텍스트의 예를 제공합니다.



== 예시



=== 영역 이름을 보여주는 예제 1

이 예에서는 정규 표현식을 사용하여 영역 이름에서 호스트 이름을 추출합니다.  다음과 같은 영역 이름이 있는 경우 정규 표현식을 만들 수 있습니다.

* S0032_myComputer1Name-HBA0
* S0434_myComputer1Name-HBA1
* S0432_myComputer1Name-HBA3


호스트 이름을 캡처하는 데 사용할 수 있는 정규 표현식은 다음과 같습니다.

 S[0-9]+_([a-zA-Z0-9]*)[_-]HBA[0-9]
결과는 S로 시작하고 숫자 조합 뒤에 밑줄, 영숫자 호스트 이름(myComputer1Name), 밑줄 또는 하이픈, 대문자 HBA, 단일 숫자(0-9)가 오는 모든 영역과 일치합니다.  호스트 이름만 *\1* 변수에 저장됩니다.

정규 표현식은 다음과 같은 구성 요소로 나눌 수 있습니다.

* "S"는 영역 이름을 나타내며 표현식을 시작합니다.  이는 영역 이름의 시작 부분에 있는 "S"와만 일치합니다.
* 괄호 안의 문자 [0-9]는 "S" 뒤에 오는 숫자가 0과 9 사이의 숫자여야 함을 나타냅니다.
* + 기호는 앞의 괄호 안의 정보가 1회 이상 나타나야 함을 나타냅니다.
* _ (밑줄)은 S 뒤에 오는 숫자 바로 뒤에 구역 이름에 밑줄 문자만 와야 한다는 것을 의미합니다.  이 예에서 영역 명명 규칙은 밑줄을 사용하여 영역 이름과 호스트 이름을 구분합니다.
* 필수 밑줄 뒤에 있는 괄호는 그 안에 포함된 패턴이 \1 변수에 저장됨을 나타냅니다.
* 괄호로 묶인 문자 [a-zA-Z0-9]는 일치되는 문자가 모두 문자(대소문자 구분 없음)와 숫자임을 나타냅니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생함을 나타냅니다.
* 괄호로 묶인 문자 [_-](밑줄과 대시)는 영숫자 패턴 뒤에 밑줄이나 대시가 와야 함을 나타냅니다.
* 정규 표현식의 HBA 문자는 이 정확한 문자 시퀀스가 영역 이름에 나타나야 함을 나타냅니다.
* 마지막 괄호 문자 [0-9]는 0에서 9까지의 숫자 한 개와 일치합니다.




=== 예제 2

이 예에서 첫 번째 밑줄 "_"까지 건너뛴 다음, E와 그 뒤의 두 번째 "_"까지 모든 것을 일치시키고, 그 이후의 모든 것을 건너뜁니다.

*존:* Z_E2FHDBS01_E1NETAPP

*호스트 이름:* E2FHDBS01

*정규식:* .*?_(E.*?)_.*?



=== 예제 3

정규 표현식(아래)의 마지막 섹션을 둘러싼 괄호 "( )"는 어느 부분이 호스트 이름인지를 식별합니다.  VSAN3을 호스트 이름으로 사용하려면 [a-zA-Z0-9]+_([a-zA-Z0-9]+).*가 됩니다.

*존:* A_VSAN3_SR48KENT_A_CX2578_SPA0

*호스트 이름:* SR48KENT

*정규식:* [a-zA-Z0-9]+_[a-zA-Z0-9]+_([a-zA-Z0-9]+).*



=== 더 복잡한 명명 패턴을 보여주는 예제 4

다음과 같은 영역 이름이 있는 경우 정규 표현식을 만들 수 있습니다.

* 내 컴퓨터 이름 123-HBA1_Symm1_FA3
* 내 컴퓨터 이름 123-HBA2_Symm1_FA5
* myComputerName123-HBA3_Symm1_FA7


이러한 문제를 포착하는 데 사용할 수 있는 정규 표현식은 다음과 같습니다.

 ([a-zA-Z0-9]*)_.*
이 표현식으로 평가된 후에는 \1 변수에 _myComputerName123_만 포함됩니다.

정규 표현식은 다음과 같은 구성 요소로 나눌 수 있습니다.

* 괄호는 패턴이 \1 변수에 저장됨을 나타냅니다.
* 괄호로 묶인 문자 [a-zA-Z0-9]는 대소문자에 관계없이 모든 문자 또는 숫자가 일치함을 의미합니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생함을 나타냅니다.
* 정규 표현식의 _ (밑줄) 문자는 영역 이름에 앞의 괄호와 일치하는 영숫자 문자열 바로 뒤에 밑줄이 있어야 함을 의미합니다.
* 그 .  (마침표)는 모든 문자(와일드카드)와 일치합니다.
* * (별표)는 앞의 마침표 와일드카드가 0번 이상 나타날 수 있음을 나타냅니다.
+
즉, .* 조합은 모든 문자를 여러 번 반복해서 나타낼 수 있습니다.





=== 패턴이 없는 영역 이름을 보여주는 예제 5

다음과 같은 영역 이름이 있는 경우 정규 표현식을 만들 수 있습니다.

* myComputerName_HBA1_Symm1_FA1
* myComputerName123_HBA1_Symm1_FA1


이러한 문제를 포착하는 데 사용할 수 있는 정규 표현식은 다음과 같습니다.

 (.*?)_.*
\1 변수에는 _myComputerName_(첫 번째 영역 이름 예시) 또는 _myComputerName123_(두 번째 영역 이름 예시)이 포함됩니다.  따라서 이 정규 표현식은 첫 번째 밑줄 이전의 모든 것과 일치합니다.

정규 표현식은 다음과 같은 구성 요소로 나눌 수 있습니다.

* 괄호는 패턴이 \1 변수에 저장됨을 나타냅니다.
* .*  (마침표 별표)는 모든 문자와 여러 번 일치합니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생함을 나타냅니다.
* ? 문자는 탐욕스럽지 않은 매치를 만듭니다.  이렇게 하면 마지막이 아닌 첫 번째 밑줄에서 일치를 중지하게 됩니다.
* 문자 _.*는 첫 번째로 발견된 밑줄과 그 뒤에 오는 모든 문자와 일치합니다.




=== 패턴을 사용하여 컴퓨터 이름을 표시하는 예 6

다음과 같은 영역 이름이 있는 경우 정규 표현식을 만들 수 있습니다.

* Storage1_Switch1_myComputerName123A_A1_FC1
* Storage2_Switch2_myComputerName123B_A2_FC2
* Storage3_Switch3_myComputerName123T_A3_FC3


이러한 문제를 포착하는 데 사용할 수 있는 정규 표현식은 다음과 같습니다.

 .*?_.*?_([a-zA-Z0-9]*[ABT])_.*
영역 명명 규칙에는 패턴이 더 많으므로 위의 표현식을 사용할 수 있습니다. 이 표현식은 A, B 또는 T로 끝나는 모든 호스트 이름(예시에서는 myComputerName)과 일치하며 해당 호스트 이름을 \1 변수에 넣습니다.

정규 표현식은 다음과 같은 구성 요소로 나눌 수 있습니다.

* .*  (마침표 별표)는 모든 문자와 여러 번 일치합니다.
* ? 문자는 탐욕스럽지 않은 매치를 만듭니다.  이렇게 하면 마지막이 아닌 첫 번째 밑줄에서 일치를 중지하게 됩니다.
* 밑줄 문자는 영역 이름의 첫 번째 밑줄과 일치합니다.
* 따라서 첫 번째 .*?_ 조합은 첫 번째 영역 이름 예의 문자 Storage1_과 일치합니다.
* 두 번째 .*?_ 조합은 첫 번째와 비슷하게 동작하지만 첫 번째 영역 이름 예의 Switch1_과 일치합니다.
* 괄호는 패턴이 \1 변수에 저장됨을 나타냅니다.
* 괄호로 묶인 문자 [a-zA-Z0-9]는 대소문자에 관계없이 모든 문자 또는 숫자가 일치함을 의미합니다.
* 괄호 뒤에 있는 * (별표)는 괄호 안의 문자가 0번 이상 발생함을 나타냅니다.
* 정규 표현식 [ABT]의 대괄호 문자는 영역 이름의 단일 문자와 일치하며, 이 문자는 A, B 또는 T여야 합니다.
* 괄호 뒤에 있는 _ (밑줄)은 [ABT] 문자 일치 뒤에 밑줄이 와야 함을 나타냅니다.
* .*  (마침표 별표)는 모든 문자와 여러 번 일치합니다.


따라서 이 결과로 \1 변수에는 다음과 같은 영숫자 문자열이 포함됩니다.

* 몇 개의 영숫자 문자와 두 개의 밑줄이 앞에 붙었습니다.
* 밑줄(그리고 임의의 수의 영숫자 문자)이 뒤에 옵니다.
* 세 번째 밑줄 앞에 A, B 또는 T라는 마지막 문자가 있습니다.




=== 예제 7

*존:* myComputerName123_HBA1_Symm1_FA1

*호스트 이름:* myComputerName123

*정규식:* ([a-zA-Z0-9]+)_.*



=== 예제 8

이 예제에서는 첫 번째 _ 앞에 있는 모든 것을 찾습니다.

영역: MyComputerName_HBA1_Symm1_FA1

MyComputerName123_HBA1_Symm1_FA1

호스트 이름: MyComputerName

정규식: (.*?)_.*



=== 예제 9

이 예제에서는 첫 번째 _ 이후부터 두 번째 _까지의 모든 내용을 찾습니다.

*존:* Z_내 컴퓨터 이름_저장소 이름

*호스트 이름:* 내 컴퓨터 이름

*정규식:* .*?_(.*?)_.*?



=== 예제 10

이 예제에서는 영역 예제에서 "MyComputerName123"을 추출합니다.

*존:* Storage1_Switch1_MyComputerName123A_A1_FC1

Storage2_Switch2_MyComputerName123B_A2_FC2

Storage3_Switch3_MyComputerName123T_A3_FC3

*호스트 이름:* MyComputerName123

*정규식:* .*?_.*?_([a-zA-Z0-9]+)*[ABT]_.*



=== 예제 11

*존:* Storage1_Switch1_MyComputerName123A_A1_FC1

*호스트 이름:* MyComputerName123A

*정규식:* .*?_.*?_([a-zA-z0-9]+)_.*?_



=== 예제 12

^ (곡절 기호 또는 캐럿)은 *대괄호* 안에 들어 있으며 표현식을 부정합니다. 예를 들어, [^Ff]는 대문자 또는 소문자 F를 제외한 모든 문자를 의미하고, [^az]는 소문자 a~z를 제외한 모든 문자를 의미하며, 위의 경우에는 _를 제외한 모든 문자를 의미합니다.  포맷 명령문은 출력 호스트 이름에 "-"를 추가합니다.

*존:* mhs_apps44_d_A_10a0_0429

*호스트 이름:* mhs-apps44-d

*RegExp:* ([^_]+)_([AB]).* Data Infrastructure Insights 의 형식: \1-\2 ([^_]+)_ ([^_]+)_([^_]+).* Data Infrastructure Insights 의 형식: \1-\2-\3



=== 예제 13

이 예에서 저장 별칭은 "\"로 구분되고 표현식은 "\\"를 사용하여 문자열에 실제로 "\"가 사용되고 있으며 표현식 자체의 일부가 아니라는 것을 정의해야 합니다.

*저장소 별칭:* \Hosts\E2DOC01C1\E2DOC01N1

*호스트 이름:* E2DOC01N1

*정규식:* \\.*?\\.*?\\(.*?)



=== 예제 14

이 예제에서는 영역 예제에서 "PD-RV-W-AD-2"를 추출합니다.

*구역:* PD_D-PD-RV-W-AD-2_01

*호스트 이름:* PD-RV-W-AD-2

*정규식:* [^-]+-(.*-\d+).*



=== 예제 15

이 경우의 형식 설정은 호스트 이름에 "US-BV-"를 추가합니다.

*존:* SRV_USBVM11_F1

*호스트 이름:* US-BV-M11

*정규식:* SRV_USBV([A-Za-z0-9]+)_F[12]

*형식:* US-BV-\1
